// --- Prisma Schema ---

datasource db {
  provider = "postgresql"
}

generator client {
  provider = "prisma-client-js"
}

enum UserRole {
  CLIENT
  COLLECTOR
  ADMIN
}

enum ClientType {
  individual
  company
}

enum CollectionType {
  HOME_PICKUP
  DROP_OFF_POINT
  BOTH
}

// Linhas de materiais (substitui acceptedMaterials String[])
enum MaterialLine {
  VERDE
  MARROM
  AZUL
  BRANCA
}

// Modalidade do descarte solicitado pelo cliente
enum DiscardMode {
  COLLECTION_POINT
  PICKUP
}

// Status do descarte ao longo do fluxo
enum DiscardStatus {
  PENDING      // Criado aguardando ação (se PICKUP) ou aguardando ida ao ponto
  OFFERED      // Coletor enviou opções de dia/horário
  SCHEDULED    // Cliente escolheu um horário
  CANCELLED    // Cancelado pelo cliente ou coletor
  COMPLETED    // Concluído (material recolhido ou entregue)
}

// Status da oferta de coleta enviada por um coletor
enum OfferStatus {
  PENDING
  ACCEPTED
  REJECTED
  WITHDRAWN
}

// ==================== USUÁRIOS ====================

model User {
  id                    Int       @id(map: "users_pk") @default(autoincrement())
  email                 String    @unique(map: "users_unique") @db.VarChar(255)
  password              String    @db.VarChar(255)
  role                  UserRole  @default(CLIENT)
  createdAt             DateTime  @default(now()) @db.Timestamp(6)
  editedAt              DateTime? @db.Timestamp(6)
  resetToken            String?   @db.VarChar(255)
  resetTokenGeneratedAt DateTime? @db.Timestamp(6)
  Client                Client?
  Collector             Collector?
}

// ==================== CLIENTES ====================

model Client {
  id         Int         @id(map: "clients_pk") @default(autoincrement())
  type       ClientType
  phone      String      @db.VarChar(20)
  avatarUrl  String?     @db.VarChar(500)
  userId     Int         @unique(map: "clients_users_id_key")
  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade, map: "clients_users_id_fkey")
  individual Individual?
  company    Company?
  address    Address?
  createdAt  DateTime    @default(now()) @db.Timestamp(6)
  editedAt   DateTime?   @db.Timestamp(6)
  discards   Discard[]
}

model Individual {
  id        Int       @id(map: "individuals_pk") @default(autoincrement())
  firstName String    @db.VarChar(100)
  lastName  String    @db.VarChar(100)
  cpf       String    @unique(map: "individuals_unique") @db.VarChar(14)
  clientId  Int       @unique(map: "individuals_clients_id_key")
  client    Client    @relation(fields: [clientId], references: [id], onDelete: Cascade, onUpdate: Cascade, map: "individuals_clients_id_fkey")
  createdAt DateTime  @default(now()) @db.Timestamp(6)
  editedAt  DateTime? @db.Timestamp(6)
}

model Company {
  id          Int       @id(map: "companies_pk") @default(autoincrement())
  companyName String    @db.VarChar(255)
  tradeName   String    @db.VarChar(255)
  cnpj        String    @unique(map: "companies_unique") @db.VarChar(18)
  clientId    Int       @unique(map: "companies_clients_id_key")
  client      Client    @relation(fields: [clientId], references: [id], onDelete: Cascade, onUpdate: Cascade, map: "companies_clients_id_fkey")
  createdAt   DateTime  @default(now()) @db.Timestamp(6)
  editedAt    DateTime? @db.Timestamp(6)
}

model Address {
  id             Int       @id(map: "addresses_pk") @default(autoincrement())
  // addressType removido
  addressName    String    @db.VarChar(255)
  number         String    @db.VarChar(10)
  additionalInfo String?   @db.VarChar(255)
  neighborhood   String    @db.VarChar(100)
  postalCode     String    @db.VarChar(10)
  city           String    @db.VarChar(100)
  state          String    @db.VarChar(2)
  latitude       Float?
  longitude      Float?
  clientId       Int       @unique(map: "addresses_clients_id_key")
  client         Client    @relation(fields: [clientId], references: [id], onDelete: Cascade, onUpdate: Cascade, map: "addresses_clients_id_fkey")
  createdAt      DateTime  @default(now()) @db.Timestamp(6)
  editedAt       DateTime? @db.Timestamp(6)
}

// ==================== COLETORES ====================

model Collector {
  id                Int                     @id(map: "collectors_pk") @default(autoincrement())
  companyName       String                  @db.VarChar(255)
  tradeName         String                  @db.VarChar(255)
  cnpj              String                  @unique(map: "collectors_unique") @db.VarChar(18)
  phone             String                  @db.VarChar(20)
  description       String?                 @db.Text
  operatingHours    String?                 @db.VarChar(255)
  collectionType    CollectionType          @default(BOTH)
  // Linhas aceitas pelo coletor
  acceptedLines     MaterialLine[]
  userId            Int                     @unique(map: "collectors_users_id_key")
  user              User                    @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade, map: "collectors_users_id_fkey")
  headquarters      CollectorHeadquarters?
  collectionPoints  CollectionPoint[]
  offers            Offer[]
  createdAt         DateTime                @default(now()) @db.Timestamp(6)
  editedAt          DateTime?               @db.Timestamp(6)
}

model CollectorHeadquarters {
  id             Int       @id(map: "collector_headquarters_pk") @default(autoincrement())
  // addressType removido
  addressName    String    @db.VarChar(255)
  number         String    @db.VarChar(10)
  additionalInfo String?   @db.VarChar(255)
  neighborhood   String    @db.VarChar(100)
  postalCode     String    @db.VarChar(10)
  city           String    @db.VarChar(100)
  state          String    @db.VarChar(2)
  latitude       Float?
  longitude      Float?
  collectorId    Int       @unique(map: "collector_headquarters_collectors_id_key")
  collector      Collector @relation(fields: [collectorId], references: [id], onDelete: Cascade, onUpdate: Cascade, map: "collector_headquarters_collectors_id_fkey")
  createdAt      DateTime  @default(now()) @db.Timestamp(6)
  editedAt       DateTime? @db.Timestamp(6)
}

model CollectionPoint {
  id                Int       @id(map: "collection_points_pk") @default(autoincrement())
  name              String    @db.VarChar(255)
  description       String?   @db.Text
  // addressType removido
  addressName       String    @db.VarChar(255)
  number            String    @db.VarChar(10)
  additionalInfo    String?   @db.VarChar(255)
  neighborhood      String    @db.VarChar(100)
  postalCode        String    @db.VarChar(10)
  city              String    @db.VarChar(100)
  state             String    @db.VarChar(2)
  latitude          Float?
  longitude         Float?
  operatingHours    String?   @db.VarChar(255)
  // Linhas aceitas neste ponto (subconjunto de acceptedLines do coletor)
  acceptedLines     MaterialLine[]
  isActive          Boolean   @default(true)
  collectorId       Int
  collector         Collector @relation(fields: [collectorId], references: [id], onDelete: Cascade, onUpdate: Cascade, map: "collection_points_collectors_id_fkey")
  createdAt         DateTime  @default(now()) @db.Timestamp(6)
  editedAt          DateTime? @db.Timestamp(6)
  discards          Discard[]

  @@index([collectorId], map: "collection_points_collector_id_idx")
  @@index([city, state], map: "collection_points_location_idx")
}

// ==================== DESCARTES ====================

model Discard {
  id              Int           @id @default(autoincrement())
  client          Client        @relation(fields: [clientId], references: [id], onDelete: Cascade)
  clientId        Int
  mode            DiscardMode
  lines           MaterialLine[]
  description     String?       @db.Text
  // Se o cliente escolhe um ponto de coleta (COLLECTION_POINT)
  collectionPoint CollectionPoint? @relation(fields: [collectionPointId], references: [id])
  collectionPointId Int?
  status          DiscardStatus @default(PENDING)
  offers          Offer[]
  scheduledSlot   Json?         // Registro final do horário aceito {date, start, end}
  createdAt       DateTime      @default(now()) @db.Timestamp(6)
  editedAt        DateTime?     @db.Timestamp(6)

  @@index([clientId], map: "discard_client_idx")
  @@index([status], map: "discard_status_idx")
}

model Offer {
  id          Int          @id @default(autoincrement())
  discard     Discard      @relation(fields: [discardId], references: [id], onDelete: Cascade)
  discardId   Int
  collector   Collector    @relation(fields: [collectorId], references: [id], onDelete: Cascade)
  collectorId Int
  proposedSlots Json        // Lista de opções [{date, start, end}, ...]
  acceptedSlot Json?        // Slot escolhido pelo cliente
  status      OfferStatus  @default(PENDING)
  createdAt   DateTime     @default(now()) @db.Timestamp(6)
  editedAt    DateTime?    @db.Timestamp(6)
}
